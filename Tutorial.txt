SSPM - TUTORIAL COMPLETO (ediÃ§Ã£o modular lib/*.sh)
==================================================

Este arquivo-Ãºnico em texto explica como instalar e usar o sspm (ediÃ§Ã£o modular),
como organizar a Ã¡rvore de diretÃ³rios, todos os comandos e variÃ¡veis, boas prÃ¡ticas,
e traz 4 receitas de exemplo:

  0) Uma receita â€œdidÃ¡ticaâ€ com TUDO suportado (patch, check, post_install, etc.)
  1) glibc (receita real, simplificada, nativa)
  2) gcc   (receita real, simplificada, nativa)
  3) firefox (receita real, simplificada, via `mach`, empacotando binÃ¡rios)

NOTA IMPORTANTE
---------------
- Este tutorial foi escrito para a versÃ£o modular do sspm (com pastas lib/*.sh) que
  nÃ£o compila dependÃªncias de ferramentas por conta prÃ³pria e nÃ£o possui multilÃ­ngue.
- Assume um sistema com ferramentas bÃ¡sicas jÃ¡ instaladas: bash, coreutils, curl,
  tar, zstd, file, patch, grep, sed, make, gcc, pkg-config, etc.
- As receitas â€œreaisâ€ a seguir sÃ£o simplificadas para um build nativo padrÃ£o e podem
  exigir ajustes conforme a sua distro, toolchain e necessidades (CFLAGS, multilib,
  toolchain externa, LLVM/Clang, Rust, Node, Python, etc).

======================================================================
1) INSTALAÃ‡ÃƒO DO SSPM (EDIÃ‡ÃƒO MODULAR)
======================================================================

Estrutura do projeto sspm (ediÃ§Ã£o modular):

  sspm_clean/
  â”œâ”€â”€ sspm                    # binÃ¡rio principal
  â”œâ”€â”€ lib/
  â”‚   â”œâ”€â”€ core.sh             # build/install/remove + empacotamento
  â”‚   â”œâ”€â”€ deps.sh             # resoluÃ§Ã£o topolÃ³gica e orfÃ£os
  â”‚   â”œâ”€â”€ pkg.sh              # DB simples, helpers de receita
  â”‚   â””â”€â”€ ui.sh               # cores/spinner/logs
  â”œâ”€â”€ man/
  â”‚   â””â”€â”€ sspm.1              # manual separado (opcional)
  â””â”€â”€ examples/
      â””â”€â”€ hello.pkg           # receita de exemplo

InstalaÃ§Ã£o local no $HOME:
  $ cd sspm_clean
  $ chmod +x sspm
  # Opcional: adicionar ao PATH
  $ echo 'export PATH="$HOME/sspm_clean:$PATH"' >> ~/.bashrc
  $ source ~/.bashrc
  $ sspm help

InstalaÃ§Ã£o â€œglobalâ€ (requer root):
  # Instala binÃ¡rio
  $ sudo install -Dm0755 sspm /usr/local/bin/sspm
  # Instala libs
  $ sudo install -Dm0755 lib/*.sh -t /usr/local/lib/sspm
  # Instala manpage
  $ sudo install -Dm0644 man/sspm.1 /usr/local/share/man/man1/sspm.1

  # Se instalou as libs em /usr/local/lib/sspm, ajuste o sspm para localizar:
  # (no sspm, LIBDIR deve apontar para /usr/local/lib/sspm)
  # ou mantenha a estrutura lado a lado e chame ./sspm diretamente.


======================================================================
2) ÃRVORE DE DIRETÃ“RIOS RECOMENDADA PARA RECEITAS/BUILD
======================================================================

VocÃª pode organizar seus pacotes (receitas) em uma pasta â€œrepoâ€ sua:

  ~/pkgs/
  â”œâ”€â”€ base/
  â”‚   â”œâ”€â”€ glibc.pkg
  â”‚   â””â”€â”€ gcc.pkg
  â”œâ”€â”€ desktop/
  â”‚   â””â”€â”€ firefox.pkg
  â””â”€â”€ custom/
      â””â”€â”€ minha-receita.pkg

Cada diretÃ³rio (ex.: ~/pkgs/base) pode ter vÃ¡rias receitas .pkg. O sspm cria
automaticamente, no diretÃ³rio onde vocÃª chama o build, subpastas temporÃ¡rias:

  ./src/<pkgname>-<ver>-<rel>   # fontes descompactados e trabalho
  ./pkg/<pkgname>-<ver>-<rel>   # DESTDIR (Ã¡rvore final a virar .tar.zst)
  ./<pkgid>.tar.zst             # pacote binÃ¡rio final
  ./<pkgid>.manifest            # lista de arquivos do pacote (para remoÃ§Ã£o)

Banco de dados local (instalaÃ§Ãµes):
  /var/lib/sspm/                # por padrÃ£o
    â”œâ”€â”€ packages/<name>/{id,depends}
    â””â”€â”€ files/<name>.files      # manifest dos arquivos instalados

VocÃª pode alterar SSPM_DB via variÃ¡vel de ambiente (ver sessÃ£o 4).


======================================================================
3) COMANDOS DO SSPM (EDIÃ‡ÃƒO MODULAR)
======================================================================

$ sspm help
  Mostra ajuda curta.

$ sspm build <dir-ou-arquivo> [--no-strip]
  - LÃª todas as receitas *.pkg em <dir> e:
    * resolve dependÃªncias topologicamente (deps primeiro),
    * faz fetch, extract, prepare, build, check, package (quando definidas),
    * cria arquivo .tar.zst + .manifest.
  - Se passar um arquivo .pkg, compila apenas aquele (e ainda assim resolve
    deps dentro do conjunto fornecido se estiverem juntas no mesmo <dir>).
  - --no-strip: desabilita strip automÃ¡tico de binÃ¡rios.

$ sspm install <pkg.tar.zst>
  - Extrai o pacote no sistema (em /),
  - registra manifest em /var/lib/sspm/files/<name>.files,
  - registra metadados em /var/lib/sspm/packages/<name>/.

$ sspm remove <name>
  - LÃª o manifest e remove os arquivos,
  - apaga o registro do DB local,
  - executa post_remove() se definido.

$ sspm list
  - Lista pacotes instalados.

$ sspm deps <dir-ou-arquivo> [--reverse]
  - Mostra ordenaÃ§Ã£o topolÃ³gica dos pacotes do conjunto (Ãºtil para planejar build).
  - --reverse: ordem invertida (Ãºtil para remoÃ§Ã£o em cadeia).

$ sspm orphans
  - Lista pacotes instalados que nenhum outro pacote depende deles
    (checagem simples baseada nos metadados guardados).

$ sspm info <name>
  - Mostra ID, depends e caminho do manifest de um pacote instalado.


======================================================================
4) VARIÃVEIS DE AMBIENTE ÃšTEIS
======================================================================

SSPM_DB=/caminho/customizado
  - Define onde ficam os metadados e manifests (default: /var/lib/sspm).

SSPM_COLOR=auto|always|never  (respeita NO_COLOR)
  - Controle de cores no terminal.

SSPM_JOBS=N
  - Encaminhado para `make -jN` nas receitas que usarem.

SSPM_STRIP=1|0
  - Strip automÃ¡tico de binÃ¡rios (default 1; --no-strip forÃ§a 0).

===============================
 Repo de receitas

meu-repo-sspm/
â”œâ”€â”€ base/
â”‚   â”œâ”€â”€ gcc-12.0/
â”‚   â”‚   â””â”€â”€ gcc-12.0.pkg
â”‚   â”œâ”€â”€ glibc-2.39/
â”‚   â”‚   â””â”€â”€ glibc-2.39.pkg
â”‚   â””â”€â”€ make-4.4/
â”‚       â””â”€â”€ make-4.4.pkg
â”œâ”€â”€ x11/
â”‚   â””â”€â”€ xorg-21.1/
â”‚       â””â”€â”€ xorg-21.1.pkg
â”œâ”€â”€ desktop/
â”‚   â””â”€â”€ firefox-128.0/
â”‚       â””â”€â”€ firefox-128.0.pkg
â””â”€â”€ extras/
    â””â”€â”€ htop-3.3/
        â””â”€â”€ htop-3.3.pkg

------â€--------------------)-)------------

===============================
 Arquivo: tutorial-repo-sspm.txt
===============================

# ğŸ“‚ Estrutura do repositÃ³rio Git
O repositÃ³rio de receitas deve ter a seguinte organizaÃ§Ã£o:

meu-repo-sspm/
â”œâ”€â”€ base/
â”‚   â”œâ”€â”€ gcc-12.0/
â”‚   â”‚   â””â”€â”€ gcc-12.0.pkg
â”‚   â”œâ”€â”€ glibc-2.39/
â”‚   â”‚   â””â”€â”€ glibc-2.39.pkg
â”‚   â””â”€â”€ make-4.4/
â”‚       â””â”€â”€ make-4.4.pkg
â”œâ”€â”€ x11/
â”‚   â””â”€â”€ xorg-21.1/
â”‚       â””â”€â”€ xorg-21.1.pkg
â”œâ”€â”€ desktop/
â”‚   â””â”€â”€ firefox-128.0/
â”‚       â””â”€â”€ firefox-128.0.pkg
â””â”€â”€ extras/
    â””â”€â”€ htop-3.3/
        â””â”€â”€ htop-3.3.pkg

Cada pacote fica numa pasta prÃ³pria com a versÃ£o no nome e um arquivo .pkg (a receita).
Exemplo: base/gcc-12.0/gcc-12.0.pkg


# âš™ï¸ ConfiguraÃ§Ã£o no sspm

1. Escolha um local para armazenar o repo clonado
   PadrÃ£o:
       /var/lib/sspm/repo
   Ou personalizado:
       export REPO_DIR="$HOME/.local/share/sspm/repo"

2. Defina a URL do seu repositÃ³rio Git:
       export REPO_URL="https://github.com/seuuser/meu-repo-sspm.git"

3. Verifique se o sspm estÃ¡ pegando as variÃ¡veis:
       ./sspm help
       echo $REPO_URL
       echo $REPO_DIR


# ğŸš€ Como usar na prÃ¡tica

1. Sincronizar as receitas:
       ./sspm sync
   - Se ainda nÃ£o existir, ele faz git clone do seu repo em $REPO_DIR
   - Se jÃ¡ existir, ele faz git pull e atualiza

2. Instalar um pacote (com dependÃªncias):
       ./sspm install gcc
   - Procura a receita mais nova no repo
   - LÃª a lista depends=(...) da receita e instala dependÃªncias antes
   - Por fim, builda e instala o pacote

3. Atualizar pacotes jÃ¡ instalados:
       ./sspm upgrade
   - Percorre todos os pacotes instalados em $PKGDB/
   - Compara versÃ£o instalada com a mais nova no repo Git
   - Se houver versÃ£o maior, instala a nova versÃ£o automaticamente


# ğŸ“¦ Estrutura de uma receita .pkg

Exemplo: base/gcc-12.0/gcc-12.0.pkg

pkgname=gcc
pkgver=12.0
pkgrel=1
depends=(glibc make)

build() {
    ./configure --prefix=/usr
    make
}

package() {
    make DESTDIR="$PKGDEST" install
}


# ğŸ“ Resumo rÃ¡pido dos comandos

./sspm sync
    â†’ baixa/atualiza as receitas do repo Git

./sspm install <pacote>
    â†’ instala pacote + dependÃªncias

./sspm upgrade
    â†’ procura novas versÃµes no repo e atualiza



----------------------------------------------------


======================================================================
5) FORMATO DAS RECEITAS (ARQUIVOS .pkg)
======================================================================

Receita Ã© um shell script simples que define variÃ¡veis e funÃ§Ãµes:

VariÃ¡veis obrigatÃ³rias:
  pkgname=...
  pkgver=...
  pkgrel=...

Fontes e checksums:
  source=( "URL1" "URL2" ... )
  sha512sums=( "HASH1" "HASH2" ... )
    - VocÃª pode usar "SKIP" temporariamente (nÃ£o recomendado para produÃ§Ã£o).

DependÃªncias:
  depends=( pkgA pkgB ... )        # exigidas para compilar/rodar
  optdepends=( "foo: texto" ... )  # opcionais (informativo)

FunÃ§Ãµes (todas opcionais, mas normalmente define-se build() e package()):
  prepare()  # aplicar patches, gerar arquivos, etc. (roda no srcdir)
  build()    # compilar (./configure && make, cmake, ninja, etc.)
  check()    # rodar testes (make check, ctest, etc.)
  package()  # instalar no DESTDIR (pkgdir), ex: make DESTDIR="$pkgdir" install

Hooks pÃ³s-aÃ§Ã£o:
  post_install()  # roda apÃ³s instalar no sistema
  post_remove()   # roda apÃ³s remover

VariÃ¡veis de diretÃ³rio (disponibilizadas pelo sspm no build):
  startdir  -> diretÃ³rio onde estÃ¡ a receita
  srcdir    -> diretÃ³rio de trabalho dos fontes extraÃ­dos
  pkgdir    -> DESTDIR para "make install"


======================================================================
6) BOAS PRÃTICAS
======================================================================

- Sempre use DESTDIR no package(): make DESTDIR="$pkgdir" install
- Especifique sha512sums reais (evite SKIP).
- Aplique patches no prepare() com `patch -p1 < ../nome.patch`.
- Evite mexer diretamente em / durante build: tudo vai para $pkgdir.
- Controle CFLAGS/CXXFLAGS/LDFLAGS via ambiente (reprodutibilidade).
- Divida receitas (ex.: gcc) em subpacotes se quiser (gcc-libs, etc.) â€” aqui estÃ¡
  simplificado em 1 pacote para demonstraÃ§Ã£o.


======================================================================
7) RECEITA DIDÃTICA COMPLETA (usa tudo suportado)
======================================================================

Arquivo: examples/nano-full.pkg  (exemplo com patch, check e hooks)

  pkgname=nano
  pkgver=8.0
  pkgrel=1

  source=(
    "https://www.nano-editor.org/dist/v8/nano-${pkgver}.tar.xz"
    "fix-spelling.patch"
  )
  # Substitua por hashes reais; aqui estÃ¡ SKIP para simplificar
  sha512sums=(
    "SKIP"
    "SKIP"
  )

  depends=(ncurses)
  optdepends=("bash-completion: tab completion for nano")

  prepare() {
    # Estamos em $srcdir
    tar -xf "nano-${pkgver}.tar.xz"
    cd "nano-${pkgver}"
    # Aplica patch local que veio como segundo source (copiado em $srcdir)
    patch -p1 < "../fix-spelling.patch"
  }

  build() {
    cd "nano-${pkgver}"
    ./configure --prefix=/usr
    make ${SSPM_JOBS:+-j$SSPM_JOBS}
  }

  check() {
    cd "nano-${pkgver}"
    make check || true   # muitos projetos tÃªm testes intermitentes
  }

  package() {
    cd "nano-${pkgver}"
    make DESTDIR="$pkgdir" install

    # completions opcionais (exemplo)
    install -Dm0644 contrib/nano.nanorc "$pkgdir/etc/nanorc"
  }

  post_install() {
    echo "nano foi instalado. Dica: leia /etc/nanorc para ajustar syntax highlighting."
  }

  post_remove() {
    echo "nano removido. Se editou /etc/nanorc manualmente, verifique sobras."
  }

======================================================================
8) RECEITA REAL: GLIBC (simplificada)
======================================================================

OBS: Construir glibc Ã© delicado: normalmente se usa build-dir separado, toolchain
coerente e cuidado com â€”prefix. Abaixo, receita â€œnativaâ€ simplificada.

Arquivo: base/glibc.pkg

  pkgname=glibc
  pkgver=2.40
  pkgrel=1

  source=(
    "https://ftp.gnu.org/gnu/libc/glibc-${pkgver}.tar.xz"
  )
  sha512sums=(
    "SKIP"    # coloque o hash real
  )

  depends=()  # na prÃ¡tica: gcc, make, linux-headers jÃ¡ no sistema

  prepare() {
    tar -xf "glibc-${pkgver}.tar.xz"
    mkdir -p "glibc-${pkgver}-build"
  }

  build() {
    cd "glibc-${pkgver}-build"
    ../glibc-${pkgver}/configure \
      --prefix=/usr \
      --disable-werror

    make ${SSPM_JOBS:+-j$SSPM_JOBS}
  }

  check() {
    cd "glibc-${pkgver}-build"
    # Os testes da glibc demoram muito; habilite se quiser:
    # make check
    :
  }

  package() {
    cd "glibc-${pkgver}-build"
    make DESTDIR="$pkgdir" install

    # Ajustes comuns: ld.so.conf.d, nsswitch.conf, locales (opcional)
    install -dm0755 "$pkgdir/etc/ld.so.conf.d"
    echo "/usr/local/lib" > "$pkgdir/etc/ld.so.conf.d/locallib.conf"

    # (Opcional) gerar locales â€” normalmente feito em pÃ³s-instalaÃ§Ã£o
  }

  post_install() {
    # Atualiza cache do linker
    /sbin/ldconfig || ldconfig || true
    echo "glibc: ldconfig executado."
  }

  post_remove() {
    echo "glibc: verifique /etc/ld.so.conf.d para sobras personalizadas."
  }

Notas:
- Em distros reais, glibc costuma ser um pacote â€œde baseâ€ jÃ¡ presente.
- Reinstalar a glibc por cima pode corromper o sistema se nÃ£o for cuidadoso.


======================================================================
9) RECEITA REAL: GCC (simplificada, C/C++)
======================================================================

GCC precisa das libs GMP, MPFR, MPC (e em geral ISL). Em algumas distros jÃ¡ estÃ£o
presentes como bibliotecas de desenvolvimento. Aqui vamos assumir que existem na
mÃ¡quina (via sistema) â€” do contrÃ¡rio, vocÃª pode empacotÃ¡-las antes com sspm.

Arquivo: base/gcc.pkg

  pkgname=gcc
  pkgver=14.2.0
  pkgrel=1

  source=(
    "https://ftp.gnu.org/gnu/gcc/gcc-${pkgver}/gcc-${pkgver}.tar.xz"
  )
  sha512sums=(
    "SKIP"   # substitua pelo hash real
  )

  depends=(glibc gmp mpfr mpc)   # simplificado (assumindo libs jÃ¡ no sistema)

  prepare() {
    tar -xf "gcc-${pkgver}.tar.xz"
    mkdir -p "gcc-${pkgver}-build"
  }

  build() {
    cd "gcc-${pkgver}-build"

    ../gcc-${pkgver}/configure \
      --prefix=/usr \
      --enable-languages=c,c++ \
      --disable-multilib

    make ${SSPM_JOBS:+-j$SSPM_JOBS}
  }

  check() {
    cd "gcc-${pkgver}-build"
    # Testes do gcc sÃ£o muito demorados; habilite se necessÃ¡rio:
    # make -k check || true
    :
  }

  package() {
    cd "gcc-${pkgver}-build"
    make DESTDIR="$pkgdir" install

    # Ajustes comuns: symlinks, saneamento de includes/bins
    # Exemplo: garantir symlink /usr/bin/cc -> gcc
    install -dm0755 "$pkgdir/usr/bin"
    ln -sf gcc "$pkgdir/usr/bin/cc"
  }

  post_install() {
    echo "gcc instalado. VersÃ£o:"
    gcc --version || true
  }

  post_remove() {
    echo "gcc removido. Verifique se hÃ¡ outros toolchains instalados."
  }

Notas:
- Em ambientes split, vocÃª pode querer separar gcc-libs.
- Se vocÃª nÃ£o tem gmp/mpfr/mpc de sistema, crie receitas para eles e
  construa-os antes (sspm build base/).


======================================================================
10) RECEITA REAL: FIREFOX (simplificada)
======================================================================

Firefox Ã© complexÃ­ssimo. Requer Rust (>= versÃ£o suportada), Cargo, Python3,
Node.js, yasm/nasm, LLVM/binutils modernos, e uma porÃ§Ã£o de libs dev (GTK,
DBus, PulseAudio/ALSA, libffi, pixman, libvpx, zlib, zstd, etc.). Aqui vamos
mostrar uma receita que baixa o tarball de cÃ³digo-fonte e compila via `./mach`.

- A Mozilla fornece tarballs â€œ*.source.tar.xzâ€ por versÃ£o. Ajuste a versÃ£o
  conforme o que vocÃª pretende construir (ESR ou stable).

Arquivo: desktop/firefox.pkg

  pkgname=firefox
  pkgver=128.0.2
  pkgrel=1

  source=(
    "https://archive.mozilla.org/pub/firefox/releases/${pkgver}/source/firefox-${pkgver}.source.tar.xz"
  )
  sha512sums=(
    "SKIP"   # substitua pelo hash real
  )

  depends=(
    rust cargo python3 nodejs
    yasm nasm
    gtk3 dbus
    libffi pixman zlib zstd libvpx
    # ... adicione as libs necessÃ¡rias para a sua distro
  )
  optdepends=(
    "pulseaudio: Ã¡udio"
    "alsa-lib: Ã¡udio"
  )

  prepare() {
    tar -xf "firefox-${pkgver}.source.tar.xz"
    cd "firefox-${pkgver}"
    # Crie mozconfig mÃ­nimo (ajuste conforme seu ambiente)
    cat > .mozconfig <<'EOF'
ac_add_options --prefix=/usr
ac_add_options --enable-application=browser
ac_add_options --disable-debug
ac_add_options --disable-tests
mk_add_options MOZ_OBJDIR=./obj
EOF
  }

  build() {
    cd "firefox-${pkgver}"
    # Baixa toolchains e prepara ambiente (pode interagir; use --no-interactive se suportado)
    # ./mach bootstrap --no-interactive || true
    ./mach build
  }

  check() {
    cd "firefox-${pkgver}"
    # Opcional: testes sÃ£o pesados e demoram
    :
  }

  package() {
    cd "firefox-${pkgver}"

    # SaÃ­da de build normalmente fica em obj/dist/firefox
    # Vamos copiar para /usr/lib/firefox e criar um wrapper em /usr/bin
    install -dm0755 "$pkgdir/usr/lib/firefox"
    cp -a obj/dist/firefox/* "$pkgdir/usr/lib/firefox/"

    install -dm0755 "$pkgdir/usr/bin"
    cat > "$pkgdir/usr/bin/firefox" <<'EOF'
#!/usr/bin/env bash
exec /usr/lib/firefox/firefox "$@"
EOF
    chmod +x "$pkgdir/usr/bin/firefox"

    # Desktop entry e Ã­cone (se disponÃ­veis)
    install -dm0755 "$pkgdir/usr/share/applications"
    cat > "$pkgdir/usr/share/applications/firefox.desktop" <<'EOF'
[Desktop Entry]
Name=Firefox
Comment=Browse the Web
Exec=firefox %u
Terminal=false
Type=Application
Icon=firefox
Categories=Network;WebBrowser;
MimeType=text/html;x-scheme-handler/http;x-scheme-handler/https;
EOF
  }

  post_install() {
    echo "Firefox instalado em /usr/lib/firefox, binÃ¡rio /usr/bin/firefox"
  }

  post_remove() {
    echo "Firefox removido. Verifique caches do Ã­cone/menu."
  }

Notas:
- `./mach bootstrap` tenta instalar dependÃªncias de build (varia por distro).
- Ajuste a `mozconfig` para uso de system libs (libvpx, ffmpeg, etc.) e para
  otimizaÃ§Ãµes (LTO, PGO) conforme sua mÃ¡quina. Receita acima Ã© o caminho curto.


======================================================================
11) EXEMPLOS DE USO
======================================================================

Build de um conjunto de pacotes com resoluÃ§Ã£o topolÃ³gica:
  $ sspm deps ~/pkgs/base
  glibc.pkg
  gcc.pkg

  $ sspm build ~/pkgs/base
  # compila glibc e depois gcc, em ordem correta

Instalar e listar:
  $ sudo sspm install glibc-2.40-1.tar.zst
  $ sudo sspm install gcc-14.2.0-1.tar.zst
  $ sspm list

Remover em ordem reversa (Ãºtil quando um depende do outro):
  $ sspm deps ~/pkgs/base --reverse
  gcc.pkg
  glibc.pkg

  $ sudo sspm remove gcc
  $ sudo sspm remove glibc

Checar Ã³rfÃ£os:
  $ sspm orphans

Info de um pacote:
  $ sspm info gcc


======================================================================
12) DICAS FINAIS
======================================================================

- Para migrar builds complexos (como firefox) para produÃ§Ã£o:
  * Congele versÃµes das dependÃªncias dev (Rust, Node) e verifique compatibilidade.
  * Troque SKIP por SHA512 reais (confiabilidade e reprodutibilidade).
  * Parametrize flags (CFLAGS, LDFLAGS) e use `SSPM_JOBS` para paralelismo.
  * Considere dividir pacotes grandes (ex.: gcc-libs vs gcc).
- Se precisar de remoÃ§Ã£o 100% limpa, garanta que TUDO seja instalado via
  `package()` dentro de `$pkgdir` â€” assim o manifest cobre todos os arquivos.


FIM
==================================================
```î¨0î¨‚
